{
    "contents" : "##Authors:\n#   Alex Ishkin [aleksandr.ishkin@thomsonreuters.com]\n#   Dexter Pratt [depratt@ucsd.edu]\n##Created: 6 June 2014\n# Contains functions to search and retrieve networks\n\n#' Search networks in NDEx (by description)\n#' \n#' @param searchString string by which to search\n#' @param accountName string; constrain search to networks administered by this account\n#' @param skip how many networks to skip\n#' @param top how many networks to show\n#' @return Data frame with network information: ID, name, whether it is public, edge and node count; source and format of network\n#' @note Search strings may be structured\n#' @examples \\dontrun{ndex.find.networks(\"calmodulin\")}\n#' @export\nndex.find.networks <- function(searchString=\"\", accountName=FALSE, skip = 0, top = 10){\n  # searchType was an NDEx Beta feature but is not supported in v1.0. \n  # An equivalent functionality may return in future versions.\n  # Dexter 10/30/14\n  # #' @param searchType string; type of search (should be one of \"exact-match\", \"contains\", \"begins-with\")\n  # searchType <- match.arg(searchType, choices=c(\"exact-match\", \"contains\", \"begins-with\"))\n  \n  ##Form JSON to post\n  if (accountName){\n    query <- toJSON(list(searchString=searchString, accountName=accountName, skip=skip, top=top))\n  } else {\n    query <- toJSON(list(searchString=searchString, skip=skip, top=top))\n  }\n \n  ##Form route\n  route <- \"/networks/search\"\n  #is.authorized <- exists('ndex.opts', envir=NDEx.env)\n  \n  ##Get stuff\n  response_json <- ndex_rest_POST(route=route, query)\n  \n  response <- fromJSON(response_json)\n  ##Retrieve necessary data fields\n  out <- lapply(response, json_parse_network_metadata)\n  out <- do.call(rbind, out)\n  \n  return(out)\n}\n\n#' Get network metadata by ID\n#' \n#' @param network_id unique ID of the network\n#' @param json logical; whether to return JSON (TRUE) or convert it to data frame. Default FALSE \n#' @return Complete JSON response or Data frame with network metadata: ID, name, whether it is public, edge and node count; source and format of network\n#' @export\nndex.get.network.metadata <- function(network_id, json=FALSE){\n  route <- paste0(\"/networks/\", network_id)\n  response <- ndex_rest_GET(route)\n  if(json) return(response)\n  else return(json_parse_network_metadata(response))\n}\n\n#' Get network edges by ID\n#' \n#' @param network_id unique ID of the network\n#' @return \\code{\\link{ndexgraph}} object\n#' @details Uses getEdges (this procedure will return complete network with all elements)\n#' Nodes use primary ID of the base term ('represents' element)\n#' Edges use primary ID of the base term ('predicate', or 'p' element)\n#' Mapping table for the nodes is retrieved ('alias' and 'related' terms) to facilitate conversions/data mapping\n#' @note Currently fetches all edges; may be suboptimal for huge networks\n#' @export\nndex.get.network <- function(network_id, json=FALSE){\n  ##First get the metadata\n  m <- ndex.get.network.metadata(network_id)\n  count <- m$edge_count\n  \n  ##For now, just fetch all edges\n  route <- paste0(\"/networks/\", network_id, \"/edges/0/\", count)\n  ejson <- ndex_rest_GET(route)\n  \n  nw <- fromJSON(ejson)\n  \n  ##Retrieve all namespaces\n  nslist <- nw$namespaces\n  namespaces <- jsonlist2df(nslist)\n  \n  ##Retrieve all base terms\n  termlist <- nw$terms\n  terms <- jsonlist2df(termlist)\n  terms$namespace_name <- namespaces$prefix[match(terms$namespace, namespaces$jdexId)]\n  \n  ##Get node data frame\n  nodelist <- nw$nodes\n  nodes <- do.call(rbind, lapply(nodelist, function(x){c(x$name, x$id, x$represents)}))\n  nodes <- data.frame(id=names(nodelist), nodes, stringsAsFactors = FALSE)\n  colnames(nodes) <- c('node_id', 'name', 'id', 'term_id')\n  ##Append information from the terms: namespace name and ID of 'representing' term in its namespace\n  terminfo_nodes <- terms[as.character(nodes$term_id), c('name', 'namespace', 'namespace_name')]\n  colnames(terminfo_nodes)[1] <- 'ref'\n  nodes <- cbind(nodes, terminfo_nodes)\n  \n  ##Get aliases and related terms for the nodes formatted\n  node.aliases <- lapply(nodelist, '[[', 'aliases')\n  alias_df <- unlist2df(node.aliases, names=c('node_id', 'ref_id'))\n  alias_df$type <- 'Alias'\n  node.related <- lapply(nodelist, '[[', 'relatedTerms')\n  related_df <- unlist2df(node.related, names=c('node_id', 'ref_id'))\n  related_df$type <- 'Related'\n  node.annot <- rbind(alias_df, related_df)\n  terminfo_annot <- terms[as.character(node.annot$ref_id), c('name', 'namespace', 'namespace_name')]\n  colnames(terminfo_annot)[1] <- 'ref'\n  node.annot <- cbind(node.annot, terminfo_annot)\n  \n  ##Retrieve all edges\n  edgelist <- nw$edges\n  edges <- jsonlist2df(edgelist)\n  ##Append information from the terms: namespace name and ID of predicate in this namespace\n  terminfo_edges <- terms[as.character(edges$p), c('name', 'namespace', 'namespace_name')]\n  colnames(terminfo_edges)[1] <- 'edge_desc'\n  edges <- cbind(edges, terminfo_edges)\n  \n  out <- new('ndexgraph',\n             nodes = nodes,\n             edges = edges,\n             node_annot = node.annot,\n             metadata = m,\n             name = m$network_name,\n             id = m$network_id)\n}\n\n\n##########################################################\n##Auxiliary format conversion code (JSON -> list -> data frame)\n#' Misc operations with lists (helps converting JSON to tabular formats)\n#'\n#' @param l list\n#' @name aux_list\nNULL\n\n#' @rdname aux_list\n#' \n#' @details \\code{jsonlist2df} flattens JSON-derived list and returns a vector. NULLs are replaced with emply string (\"\"); non-vector elements and vector elements with length > 1 are dropped\n#' @examples jsonlist2vector(list(a=1, b=NULL, c=1:3, d='v'))\njsonlist2vector <- function(l){\n  if(!is.list(l)) stop(\"list  expected\")\n  l <- lapply(l, function(x){if(is.null(x)) return('') else return(x)})\n  l[sapply(l, is.list)] <- ''\n  l[sapply(l, length) > 1] <- NULL\n  cc <- unlist(l)\n  return(cc)\n}\n\n#' @rdname aux_list\n#' \n#' @details \\code{jsonlist2df} converts JSON-derived lists of the same structure into a data frame. each row corresponds to first order element in l\n#'  for each row, NULLs are replaced with emply string (\"\"); non-vector elements and vector elements with length > 1 are dropped\njsonlist2df <- function(l){\n  if(!is.list(l)) stop(\"list  expected\")\n  ll <- lapply(l, jsonlist2vector)\n  ll_lengths <- sapply(ll, length)\n  if(dim(table(ll_lengths)) != 1) stop(\"jsonlist2df: Elements of list have different structure, impossible to convert to a data frame\")\n  df <- do.call(rbind, ll)\n  df <- as.data.frame(df, stringsAsFactors=FALSE)\n  return(df)\n}\n\n#' @rdname aux_list\n#' @param names character vector of length 2 with column names for output\n#' @details \\code{unlist2df} turns named list into a data frame where 1st column has names of list elements and 2nd has corrsponding values. List should be named and should contain vectors. Non-vector elements will be dropped\nunlist2df <- function(l, names=c('key', 'value')){\n  if(!is.list(l)) stop(\"list  expected\")\n  ##Drop non-vector elements\n  l[!(sapply(l, is.vector))] <- NULL\n  keys <- rep(names(l), sapply(l, length))\n  values <- unlist(l)\n  out <- data.frame(keys, values, stringsAsFactors=FALSE)\n  names(out) <- names\n  return(out)\n}\n\n#' Convert JSON of network metadata to data frame\n#' \n#' @param nd list with network metadata information (JSON or parsed JSON)\n#' @return Data frame with network information: ID, name, whether it is public, edge and node count; source and format of network\njson_parse_network_metadata <- function(nd){\n  if(!is.list(nd)) nd <- fromJSON(nd)\n  if(any(sapply(nd, is.null))) nd <- lapply(nd, function(x){if(is.null(x)) return('') else return(x)})\n  out <- data.frame(network_id = nd$id,\n                    network_name = nd$name,\n                    node_count = nd$nodeCount,\n                    edge_count = nd$edgeCount,\n                    isPublic = nd$isPublic,\n                    source = nd$metadata['Source'],\n                    format = nd$metadata['Format'],\n                    stringsAsFactors=FALSE)\n  return(out)\n}\n",
    "created" : 1413676251169.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "1028670008",
    "id" : "4CB0D8C3",
    "lastKnownWriteTime" : 1414640363,
    "path" : "~/Projects/ndex-r-client/R/ndex_networks.r",
    "project_path" : "R/ndex_networks.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}